#+TITLE: Illustrations for The Phantom Faculty
#+AUTHOR: mu2tau + Claude
#+DATE: 2026-02-24
#+STARTUP: showall
#+PROPERTY: header-args:python :results file :exports both :eval no-export

* Illustrations for The Phantom Faculty

These illustrations accompany /The Phantom Faculty/, an essay on
twenty-one cognitive modes for scientific understanding.

The visual language: chalkboard-and-manuscript. Dark slate
backgrounds with chalk-white and coloured annotations ---
evoking a physicist's blackboard where ideas are sketched, erased,
and sketched again. Each illustration is a /diagram of cognition/,
not a portrait of a person.

** The Faculty Assembled
:PROPERTIES:
:header-args:python: :tangle gen-faculty-assembled.py :results file :file the-faculty-assembled.png
:END:

The hero image. Twenty-one cognitive modes arranged in six
clusters around a central nexus. Each mode is a node; edges
connect modes that correct each other's failure modes. The layout
suggests a constellation map --- not a hierarchy but a network
of complementary ways of thinking.

#+begin_src python
"""
The Faculty Assembled — constellation map of 21 cognitive modes.

Usage:
    uv run --with matplotlib --with numpy python3 gen-faculty-assembled.py
"""

import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch, Circle
from pathlib import Path

rng = np.random.default_rng(42)

# --- Canvas: dark slate chalkboard ---
fig, ax = plt.subplots(figsize=(14, 10), dpi=200)
SLATE = "#1a1a2e"
CHALK = "#e8e4d4"
CHALK_DIM = "#8a8678"
fig.patch.set_facecolor(SLATE)
ax.set_facecolor(SLATE)
ax.set_xlim(-7.5, 7.5)
ax.set_ylim(-5.5, 5.5)
ax.set_aspect("equal")
ax.axis("off")

# --- Cluster colours ---
COLOURS = {
    "physics":     "#7eb8da",   # cool blue
    "measurement": "#d4a574",   # warm ochre
    "information": "#a8d4a0",   # soft green
    "computation": "#d4a0c4",   # muted mauve
    "mathematics": "#dac87e",   # gold
    "meta":        "#c4c4c4",   # silver
    "us":          "#e8e4d4",   # chalk white
}

# --- Phantom positions (x, y, name, cluster) ---
# Physics cluster — upper left
phantoms = [
    # Physics
    (-4.5,  3.5, "Landau",   "physics",     "Derivation"),
    (-2.8,  4.2, "Thorne",   "physics",     "Geometric\nIntuition"),
    (-4.8,  1.8, "Feynman",  "physics",     "Encounter"),
    (-2.5,  2.2, "Susskind", "physics",     "Compression"),
    # Measurement — left
    (-6.0,  0.0, "Faraday",  "measurement", "Active\nMeasurement"),
    (-5.8, -1.8, "Humboldt", "measurement", "Passive\nObservation"),
    (-4.2, -0.8, "Helmholtz","measurement", "Instrument-\nTheory Unity"),
    # Information — lower left
    (-2.8, -2.5, "Shannon",  "information", "Playful\nFormalisation"),
    (-1.0, -3.5, "Jaynes",   "information", "Radical\nConsistency"),
    (-3.2, -4.2, "MacKay",   "information", "Unified\nComputation"),
    # Computation — lower right
    ( 1.5, -3.0, "Hinton",   "computation", "Mechanistic\nImagination"),
    ( 3.2, -3.8, "Hopfield", "computation", "Physical\nIsomorphism"),
    ( 2.8, -1.8, "Karpathy", "computation", "Minimal\nBuilding"),
    # Mathematics — upper right
    ( 3.0,  3.8, "Gauss",    "mathematics", "Computational\nPatience"),
    ( 5.0,  3.0, "Riemann",  "mathematics", "Conceptual\nArchitecture"),
    ( 4.5,  1.2, "Erdős",    "mathematics", "Itinerant\nConnection"),
    ( 2.5,  1.8, "Tao",      "mathematics", "Strategic\nMetacognition"),
    ( 5.5,  0.0, "Thurston", "mathematics", "Embodied\nGeometry"),
    # Meta — centre-right
    ( 1.0,  1.0, "Poincaré", "meta",        "Creative\nIncubation"),
    ( 0.5, -0.8, "Hofstadter","meta",       "Strange\nLoops"),
    (-0.8,  0.2, "Bateson",  "meta",        "Pattern\nConnects"),
]

# --- Draw chalk-dust texture ---
n_dust = 3000
dx = rng.uniform(-7.4, 7.4, n_dust)
dy = rng.uniform(-5.4, 5.4, n_dust)
ds = rng.uniform(0.1, 0.6, n_dust)
da = rng.uniform(0.01, 0.04, n_dust)
ax.scatter(dx, dy, s=ds, c=CHALK, alpha=da, edgecolors="none")

# --- Draw cluster labels (faint, large) ---
cluster_labels = [
    (-3.8,  4.8, "THE PHYSICISTS",      COLOURS["physics"]),
    (-6.2,  1.2, "THE MEASURERS",       COLOURS["measurement"]),
    (-3.5, -4.8, "THE INFORMATION\nTHEORISTS", COLOURS["information"]),
    ( 2.5, -4.5, "THE COMPUTATIONAL\nTHINKERS",  COLOURS["computation"]),
    ( 4.5,  4.6, "THE MATHEMATICIANS",  COLOURS["mathematics"]),
    ( 0.8,  2.0, "THE META-\nTHINKERS", COLOURS["meta"]),
]
for x, y, label, col in cluster_labels:
    ax.text(x, y, label, fontsize=7, fontfamily="serif",
            color=col, alpha=0.35, ha="center", va="center",
            fontweight="bold", linespacing=1.2)

# --- Draw connecting edges (correction relationships) ---
# Each edge represents: "this mode corrects that mode's failure"
corrections = [
    # Landau <-> Thorne (rigour <-> intuition)
    ("Landau", "Thorne"),
    # Feynman <-> Landau (encounter <-> derivation)
    ("Feynman", "Landau"),
    # Susskind <-> Feynman (compression <-> exploration)
    ("Susskind", "Feynman"),
    # Faraday <-> Helmholtz (serendipity <-> system)
    ("Faraday", "Helmholtz"),
    # Humboldt <-> Faraday (passive <-> active)
    ("Humboldt", "Faraday"),
    # Shannon <-> Jaynes (formalisation <-> consistency)
    ("Shannon", "Jaynes"),
    # MacKay <-> Jaynes (computation <-> proof)
    ("MacKay", "Jaynes"),
    # Hinton <-> Hopfield (mechanism <-> isomorphism)
    ("Hinton", "Hopfield"),
    # Karpathy <-> Hinton (building <-> imagination)
    ("Karpathy", "Hinton"),
    # Gauss <-> Riemann (computation <-> abstraction)
    ("Gauss", "Riemann"),
    # Erdős <-> Riemann (problems <-> frameworks)
    ("Erdős", "Riemann"),
    # Tao <-> Gauss (strategy <-> patience)
    ("Tao", "Gauss"),
    # Thurston <-> Landau (embodied <-> formal)
    ("Thurston", "Landau"),
    # Poincaré <-> Tao (incubation <-> strategy)
    ("Poincaré", "Tao"),
    # Hofstadter <-> Karpathy (loops <-> grounding)
    ("Hofstadter", "Karpathy"),
    # Bateson <-> Jaynes (pattern <-> rigour)
    ("Bateson", "Jaynes"),
    # Cross-cluster bridges
    ("Helmholtz", "Landau"),
    ("Shannon", "Susskind"),
    ("Hopfield", "Thurston"),
    ("MacKay", "Karpathy"),
    ("Poincaré", "Feynman"),
    ("Bateson", "Humboldt"),
]

name_to_pos = {p[2]: (p[0], p[1]) for p in phantoms}

for n1, n2 in corrections:
    x1, y1 = name_to_pos[n1]
    x2, y2 = name_to_pos[n2]
    # hand-drawn wobble
    n_pts = 40
    t = np.linspace(0, 1, n_pts)
    jx = rng.normal(0, 0.02, n_pts)
    jy = rng.normal(0, 0.02, n_pts)
    lx = x1 + (x2 - x1) * t + jx
    ly = y1 + (y2 - y1) * t + jy
    ax.plot(lx, ly, color=CHALK_DIM, lw=0.4, alpha=0.3)

# --- Draw phantom nodes ---
for x, y, name, cluster, skill in phantoms:
    col = COLOURS[cluster]

    # Glow
    glow = Circle((x, y), 0.55, color=col, alpha=0.06)
    ax.add_patch(glow)
    glow2 = Circle((x, y), 0.35, color=col, alpha=0.10)
    ax.add_patch(glow2)

    # Node
    node = Circle((x, y), 0.18, facecolor=col, edgecolor=CHALK,
                  linewidth=0.6, alpha=0.85, zorder=5)
    ax.add_patch(node)

    # Name
    ax.text(x, y - 0.35, name, fontsize=7.5, fontfamily="serif",
            fontweight="bold", color=col, ha="center", va="top",
            zorder=6)

    # Skill label
    ax.text(x, y - 0.62, skill, fontsize=5, fontfamily="serif",
            fontstyle="italic", color=CHALK_DIM, ha="center",
            va="top", zorder=6, linespacing=1.1)

# --- Central label: Construction (us) ---
cx, cy = 0.0, -1.8
col_us = COLOURS["us"]
glow = Circle((cx, cy), 0.7, color=col_us, alpha=0.05)
ax.add_patch(glow)
glow2 = Circle((cx, cy), 0.45, color=col_us, alpha=0.08)
ax.add_patch(glow2)
node = Circle((cx, cy), 0.22, facecolor=col_us, edgecolor=CHALK,
              linewidth=0.8, alpha=0.9, zorder=5)
ax.add_patch(node)
ax.text(cx, cy - 0.42, "Construction", fontsize=8, fontfamily="serif",
        fontweight="bold", color=col_us, ha="center", va="top", zorder=6)
ax.text(cx, cy - 0.72, "Verified\nBuilding", fontsize=5.5,
        fontfamily="serif", fontstyle="italic", color=CHALK_DIM,
        ha="center", va="top", zorder=6, linespacing=1.1)

# Connect Construction to several phantoms
for target in ["Feynman", "Karpathy", "MacKay", "Gauss", "Helmholtz", "Hofstadter"]:
    tx, ty = name_to_pos[target]
    n_pts = 40
    t = np.linspace(0, 1, n_pts)
    lx = cx + (tx - cx) * t + rng.normal(0, 0.02, n_pts)
    ly = cy + (ty - cy) * t + rng.normal(0, 0.02, n_pts)
    ax.plot(lx, ly, color=CHALK, lw=0.5, alpha=0.2)

# --- Title ---
ax.text(0, 5.2, "THE PHANTOM FACULTY",
        fontsize=18, fontfamily="serif", fontweight="bold",
        color=CHALK, ha="center", va="center", zorder=7,
        alpha=0.9)
ax.text(0, 4.75, "twenty-one cognitive modes for scientific understanding",
        fontsize=9, fontfamily="serif", fontstyle="italic",
        color=CHALK_DIM, ha="center", va="center", zorder=7)

# --- Bottom attribution ---
ax.text(0, -5.3,
        "each node is a mode of cognition  \u00b7  "
        "each edge connects a mode to its corrective",
        fontsize=6, fontfamily="serif", fontstyle="italic",
        color=CHALK_DIM, ha="center", va="center", alpha=0.5)

# --- Save ---
out_dir = Path(__file__).parent
for ext in ("png",):
    out = out_dir / f"the-faculty-assembled.{ext}"
    fig.savefig(out, bbox_inches="tight", dpi=200,
                facecolor=fig.get_facecolor(), pad_inches=0.2)
    print(f"Saved: {out}")
plt.close()
#+end_src

#+RESULTS:
[[file:the-faculty-assembled.png]]

** The Landau Mode --- Derivation
:PROPERTIES:
:header-args:python: :tangle gen-mode-landau.py :results file :file mode-landau.png
:END:

A visual representation of the derivation mode: a chain of
logical steps on a chalkboard, each step connected to the next
by an arrow, with named premises on the left margin and the
conclusion illuminated at the bottom. The chain is real ---
the actual derivation of the Bloch precession from the torque
equation.

#+begin_src python
"""
The Landau Mode — a derivation chain on a chalkboard.

Usage:
    uv run --with matplotlib --with numpy python3 gen-mode-landau.py
"""

import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import FancyArrowPatch, FancyBboxPatch
from pathlib import Path

rng = np.random.default_rng(42)

fig, ax = plt.subplots(figsize=(10, 12), dpi=200)
SLATE = "#1a1a2e"
CHALK = "#e8e4d4"
CHALK_DIM = "#8a8678"
BLUE = "#7eb8da"
GOLD = "#dac87e"

fig.patch.set_facecolor(SLATE)
ax.set_facecolor(SLATE)
ax.set_xlim(-5, 5)
ax.set_ylim(-6.5, 6.5)
ax.set_aspect("equal")
ax.axis("off")

# --- Chalk dust ---
n_dust = 2000
ax.scatter(rng.uniform(-4.9, 4.9, n_dust),
           rng.uniform(-6.4, 6.4, n_dust),
           s=rng.uniform(0.1, 0.5, n_dust),
           c=CHALK, alpha=rng.uniform(0.01, 0.03, n_dust),
           edgecolors="none")

# --- Derivation steps ---
steps = [
    (r"$\mathbf{M}$ = magnetic moment of spin ensemble",
     "Definition"),
    (r"$\boldsymbol{\tau} = \gamma\, \mathbf{M} \times \mathbf{B}$",
     "Torque on magnetic\nmoment in field $\\mathbf{B}$"),
    (r"$\frac{d\mathbf{M}}{dt} = \gamma\, \mathbf{M} \times \mathbf{B}$",
     "Newton's second\nlaw for angular\nmomentum"),
    (r"$\dot{M}_x = \gamma (M_y B_z - M_z B_y)$",
     "Component form\n($x$-component)"),
    (r"$|\mathbf{M}|$ is conserved  $\Leftarrow$  $\mathbf{M} \cdot \dot{\mathbf{M}} = 0$",
     "Cross product is\northogonal to $\\mathbf{M}$"),
    (r"$\omega_L = \gamma |\mathbf{B}|$   :   Larmor frequency",
     "The measurement\nequation"),
]

n_steps = len(steps)
y_top = 5.5
y_bot = -4.5
y_positions = np.linspace(y_top, y_bot, n_steps)

for i, ((eq, premise), y) in enumerate(zip(steps, y_positions)):
    # Premise label (left margin)
    ax.text(-4.5, y, premise, fontsize=7, fontfamily="serif",
            fontstyle="italic", color=CHALK_DIM, ha="left",
            va="center", linespacing=1.2, alpha=0.6)

    # Step number
    ax.text(-1.8, y + 0.25, f"({i+1})", fontsize=7, fontfamily="serif",
            color=BLUE, ha="center", va="center", alpha=0.7)

    # Equation
    text_col = GOLD if i == n_steps - 1 else CHALK
    text_size = 13 if i == n_steps - 1 else 11
    text_alpha = 1.0 if i == n_steps - 1 else 0.85
    ax.text(1.0, y, eq, fontsize=text_size, fontfamily="serif",
            color=text_col, ha="center", va="center",
            alpha=text_alpha)

    # Connecting arrow
    if i < n_steps - 1:
        y_next = y_positions[i + 1]
        mid_y = (y + y_next) / 2
        # hand-drawn arrow
        n_pts = 20
        t = np.linspace(0, 1, n_pts)
        arr_x = -1.8 + rng.normal(0, 0.015, n_pts)
        arr_y = y - 0.4 + (y_next + 0.4 - (y - 0.4)) * t + rng.normal(0, 0.01, n_pts)
        ax.plot(arr_x, arr_y, color=BLUE, lw=0.8, alpha=0.5)
        # arrowhead
        ax.annotate("", xy=(-1.8, y_next + 0.35),
                    xytext=(-1.8, y_next + 0.6),
                    arrowprops=dict(arrowstyle="->", color=BLUE,
                                   lw=0.8, mutation_scale=10),
                    alpha=0.5)

# --- Final result highlight ---
y_final = y_positions[-1]
highlight = FancyBboxPatch((-2.5, y_final - 0.45), 7.0, 0.9,
                           boxstyle="round,pad=0.15",
                           facecolor=GOLD, alpha=0.08,
                           edgecolor=GOLD, linewidth=0.8)
ax.add_patch(highlight)

# --- Title ---
ax.text(0, 6.3, "THE LANDAU MODE",
        fontsize=16, fontfamily="serif", fontweight="bold",
        color=BLUE, ha="center", va="center")
ax.text(0, 5.9, "every result derived  \u00b7  no equation falls from the sky",
        fontsize=8, fontfamily="serif", fontstyle="italic",
        color=CHALK_DIM, ha="center", va="center")

# --- Bottom quote ---
ax.text(0, -5.8,
        '"Can you reproduce this derivation on a blank page?"',
        fontsize=8, fontfamily="serif", fontstyle="italic",
        color=CHALK_DIM, ha="center", va="center", alpha=0.6)

# --- Left margin label ---
ax.text(-4.5, 6.0, "PREMISES", fontsize=7, fontfamily="serif",
        fontweight="bold", color=CHALK_DIM, ha="left", va="center",
        alpha=0.4, rotation=0)

# --- Save ---
out_dir = Path(__file__).parent
for ext in ("png",):
    out = out_dir / f"mode-landau.{ext}"
    fig.savefig(out, bbox_inches="tight", dpi=200,
                facecolor=fig.get_facecolor(), pad_inches=0.2)
    print(f"Saved: {out}")
plt.close()
#+end_src

#+RESULTS:
[[file:mode-landau.png]]

** The Measurers --- Three Modes of Empirical Cognition
:PROPERTIES:
:header-args:python: :tangle gen-mode-measurers.py :results file :file mode-measurers.png
:END:

A triptych showing the three modes of empirical cognition.
Left: Faraday's iron filings forming field lines (active
measurement). Centre: Humboldt's Naturgemälde (passive
observation, multiple channels). Right: Helmholtz's coil
overlaid with the equation it embodies (instrument-theory unity).

#+begin_src python
"""
The Measurers — triptych of three empirical modes.

Usage:
    uv run --with matplotlib --with numpy python3 gen-mode-measurers.py
"""

import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Rectangle, FancyBboxPatch
from pathlib import Path

rng = np.random.default_rng(42)

fig, axes = plt.subplots(1, 3, figsize=(16, 6), dpi=200)
SLATE = "#1a1a2e"
CHALK = "#e8e4d4"
CHALK_DIM = "#8a8678"
OCHRE = "#d4a574"
OCHRE_DIM = "#8a6a44"

fig.patch.set_facecolor(SLATE)

for ax in axes:
    ax.set_facecolor(SLATE)
    ax.set_aspect("equal")
    ax.axis("off")

# ===================================================================
# Panel 1: Faraday — iron filings / field lines
# ===================================================================
ax1 = axes[0]
ax1.set_xlim(-3, 3)
ax1.set_ylim(-3, 3)

# Chalk dust
ax1.scatter(rng.uniform(-2.9, 2.9, 800),
            rng.uniform(-2.9, 2.9, 800),
            s=rng.uniform(0.1, 0.4, 800),
            c=CHALK, alpha=rng.uniform(0.01, 0.03, 800),
            edgecolors="none")

# Dipole field lines
# B = (mu/4pi) * (3(m.r)r/r^5 - m/r^3), simplified to 2D dipole
n_lines = 16
for angle in np.linspace(0.15, np.pi - 0.15, n_lines // 2):
    # field line of a dipole: r = r0 sin^2(theta)
    theta = np.linspace(angle, np.pi - angle + np.pi, 200)
    r0 = 2.5 * np.sin(angle)**2
    r = r0 * np.sin(theta)**2
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    mask = (np.abs(x) < 2.8) & (np.abs(y) < 2.8) & (r > 0.35)
    # add jitter for hand-drawn feel
    x_j = x + rng.normal(0, 0.015, len(x))
    y_j = y + rng.normal(0, 0.015, len(y))
    ax1.plot(x_j[mask], y_j[mask], color=OCHRE, lw=0.7, alpha=0.6)

# Magnet at centre
ax1.add_patch(Rectangle((-0.15, -0.5), 0.3, 1.0,
              facecolor="#8b3a3a", edgecolor=CHALK, lw=0.5, zorder=5))
ax1.text(0, 0.25, "N", fontsize=7, color=CHALK, ha="center",
         va="center", fontweight="bold", zorder=6)
ax1.text(0, -0.25, "S", fontsize=7, color=CHALK, ha="center",
         va="center", fontweight="bold", zorder=6)

# Iron filings (scatter along field lines)
n_filings = 400
f_angles = rng.uniform(0, 2 * np.pi, n_filings)
f_r = rng.uniform(0.5, 2.5, n_filings)
f_x = f_r * np.cos(f_angles)
f_y = f_r * np.sin(f_angles)
# orient filings along field direction
for i in range(n_filings):
    if f_r[i] < 0.4:
        continue
    r3 = f_r[i]**3
    bx = 3 * f_x[i] * f_y[i] / (f_r[i]**5)
    by = (3 * f_y[i]**2 / (f_r[i]**5) - 1 / r3)
    b_mag = np.sqrt(bx**2 + by**2)
    if b_mag > 0:
        dx = 0.06 * bx / b_mag
        dy = 0.06 * by / b_mag
        ax1.plot([f_x[i] - dx, f_x[i] + dx],
                [f_y[i] - dy, f_y[i] + dy],
                color=OCHRE, lw=0.3, alpha=0.4)

ax1.text(0, -2.7, "FARADAY", fontsize=10, fontfamily="serif",
         fontweight="bold", color=OCHRE, ha="center", va="center")
ax1.text(0, -2.95, "active measurement", fontsize=7, fontfamily="serif",
         fontstyle="italic", color=CHALK_DIM, ha="center")

# ===================================================================
# Panel 2: Humboldt — Naturgemälde (altitude cross-section)
# ===================================================================
ax2 = axes[1]
ax2.set_xlim(-3, 3)
ax2.set_ylim(-3, 3)

# Chalk dust
ax2.scatter(rng.uniform(-2.9, 2.9, 800),
            rng.uniform(-2.9, 2.9, 800),
            s=rng.uniform(0.1, 0.4, 800),
            c=CHALK, alpha=rng.uniform(0.01, 0.03, 800),
            edgecolors="none")

# Mountain profile
n_prof = 200
mx = np.linspace(-2.5, 2.5, n_prof)
# asymmetric peak
my = -1.5 + 3.8 * np.exp(-0.5 * ((mx - 0.2) / 1.2)**2)
my += 0.3 * np.sin(mx * 3) * np.exp(-0.5 * ((mx) / 2)**2)
my_jitter = my + rng.normal(0, 0.02, n_prof)
ax2.plot(mx, my_jitter, color=CHALK, lw=1.2, alpha=0.7)
ax2.fill_between(mx, -3, my_jitter, color=CHALK, alpha=0.04)

# Vegetation zones (horizontal bands with labels)
zones = [
    (-1.5, -0.5, "tropical forest",  "#2d5a27"),
    (-0.5,  0.5, "cloud forest",     "#3a7a33"),
    ( 0.5,  1.2, "páramo",           "#6a8a44"),
    ( 1.2,  1.8, "alpine tundra",    "#8a8a5a"),
    ( 1.8,  2.3, "eternal snow",     "#c4c4c4"),
]
for y_lo, y_hi, label, col in zones:
    ax2.axhspan(y_lo, y_hi, color=col, alpha=0.08, zorder=0)
    ax2.text(2.6, (y_lo + y_hi) / 2, label, fontsize=5,
             fontfamily="serif", fontstyle="italic", color=col,
             ha="left", va="center", alpha=0.7)

# Data channels on right margin
channels = [
    (2.3, "T °C",     "#d44a4a"),
    (1.5, "P hPa",    "#4a7ad4"),
    (0.7, "B incl.",   OCHRE),
    (-0.1, "species", "#4ad47a"),
    (-0.9, "soil",    "#8a6a44"),
]
for y, label, col in channels:
    ax2.plot([-2.8, -2.4], [y, y], color=col, lw=1.5, alpha=0.5)
    ax2.text(-2.85, y, label, fontsize=5, fontfamily="serif",
             color=col, ha="right", va="center", alpha=0.7)

# Integration arrows (converging to mountain)
for y, _, col in channels:
    ax2.annotate("", xy=(-1.8, y * 0.7), xytext=(-2.3, y),
                arrowprops=dict(arrowstyle="->", color=col,
                               lw=0.5, alpha=0.3))

ax2.text(0, -2.7, "HUMBOLDT", fontsize=10, fontfamily="serif",
         fontweight="bold", color=OCHRE, ha="center", va="center")
ax2.text(0, -2.95, "passive observation", fontsize=7, fontfamily="serif",
         fontstyle="italic", color=CHALK_DIM, ha="center")

# ===================================================================
# Panel 3: Helmholtz — coil + equation
# ===================================================================
ax3 = axes[2]
ax3.set_xlim(-3, 3)
ax3.set_ylim(-3, 3)

# Chalk dust
ax3.scatter(rng.uniform(-2.9, 2.9, 800),
            rng.uniform(-2.9, 2.9, 800),
            s=rng.uniform(0.1, 0.4, 800),
            c=CHALK, alpha=rng.uniform(0.01, 0.03, 800),
            edgecolors="none")

# Helmholtz coils (two circles, side view as ellipses)
from matplotlib.patches import Ellipse
coil_col = OCHRE
for y_c in [-0.7, 0.7]:
    e = Ellipse((0, y_c), 3.6, 0.4, facecolor="none",
                edgecolor=coil_col, lw=1.8, alpha=0.7)
    ax3.add_patch(e)

# Uniform field lines between coils
for x_f in np.linspace(-1.5, 1.5, 12):
    n_pts = 30
    t = np.linspace(0, 1, n_pts)
    ly = -0.5 + 1.0 * t + rng.normal(0, 0.008, n_pts)
    lx = x_f + rng.normal(0, 0.008, n_pts)
    ax3.plot(lx, ly, color=OCHRE, lw=0.5, alpha=0.4)
    # arrowhead at midpoint
    if abs(x_f) < 1.2:
        ax3.annotate("", xy=(x_f, 0.05), xytext=(x_f, -0.05),
                    arrowprops=dict(arrowstyle="->", color=OCHRE,
                                   lw=0.5, alpha=0.4))

# Equation overlaid
ax3.text(0, -1.6,
         r"$B = \frac{8\mu_0 N I}{5\sqrt{5}\, R}$",
         fontsize=14, fontfamily="serif", color=CHALK,
         ha="center", va="center", alpha=0.85)

# Bidirectional arrow between coil and equation
ax3.annotate("", xy=(0, -1.1), xytext=(0, -0.4),
            arrowprops=dict(arrowstyle="<->", color=CHALK,
                           lw=0.8, alpha=0.5))
ax3.text(0.3, -0.75, "implies", fontsize=6, fontfamily="serif",
         fontstyle="italic", color=CHALK_DIM, ha="left",
         va="center", alpha=0.5)

# Labels
ax3.text(0, 1.8, "theory", fontsize=7, fontfamily="serif",
         fontstyle="italic", color=CHALK_DIM, ha="center", alpha=0.5)
ax3.text(0, -2.1, "instrument", fontsize=7, fontfamily="serif",
         fontstyle="italic", color=CHALK_DIM, ha="center", alpha=0.5)

ax3.text(0, -2.7, "HELMHOLTZ", fontsize=10, fontfamily="serif",
         fontweight="bold", color=OCHRE, ha="center", va="center")
ax3.text(0, -2.95, "instrument-theory unity", fontsize=7,
         fontfamily="serif", fontstyle="italic", color=CHALK_DIM,
         ha="center")

# --- Suptitle ---
fig.suptitle("THE MEASURERS", fontsize=16, fontfamily="serif",
             fontweight="bold", color=OCHRE, y=0.98)

plt.tight_layout(rect=[0, 0, 1, 0.95])

# --- Save ---
out_dir = Path(__file__).parent
for ext in ("png",):
    out = out_dir / f"mode-measurers.{ext}"
    fig.savefig(out, bbox_inches="tight", dpi=200,
                facecolor=fig.get_facecolor(), pad_inches=0.2)
    print(f"Saved: {out}")
plt.close()
#+end_src

#+RESULTS:
[[file:mode-measurers.png]]

** The Mathematicians --- Five Modes
:PROPERTIES:
:header-args:python: :tangle gen-mode-mathematicians.py :results file :file mode-mathematicians.png
:END:

Five panels, each a symbolic representation of a mathematical
mode. Gauss: a table of numbers with a pattern emerging.
Riemann: a curved surface. Erdos: a network graph. Tao: a
decision tree. Thurston: a hyperbolic tiling you can feel.

#+begin_src python
"""
The Mathematicians — five modes of mathematical cognition.

Usage:
    uv run --with matplotlib --with numpy python3 gen-mode-mathematicians.py
"""

import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, FancyBboxPatch, Polygon
from matplotlib.collections import LineCollection
from pathlib import Path

rng = np.random.default_rng(42)

fig, axes = plt.subplots(1, 5, figsize=(18, 5), dpi=200)
SLATE = "#1a1a2e"
CHALK = "#e8e4d4"
CHALK_DIM = "#8a8678"
GOLD = "#dac87e"
GOLD_DIM = "#8a7a3e"

fig.patch.set_facecolor(SLATE)

for ax in axes:
    ax.set_facecolor(SLATE)
    ax.set_aspect("equal")
    ax.axis("off")
    ax.set_xlim(-2.5, 2.5)
    ax.set_ylim(-2.5, 2.5)
    # chalk dust
    ax.scatter(rng.uniform(-2.4, 2.4, 400),
               rng.uniform(-2.4, 2.4, 400),
               s=rng.uniform(0.1, 0.3, 400),
               c=CHALK, alpha=rng.uniform(0.01, 0.03, 400),
               edgecolors="none")

# ===================================================================
# Panel 1: Gauss — computational patience (number grid with pattern)
# ===================================================================
ax1 = axes[0]

# Grid of primes / composites — pattern emerging
primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47}
grid_size = 7
for row in range(grid_size):
    for col in range(grid_size):
        n = row * grid_size + col + 1
        x = -1.8 + col * 0.6
        y = 1.8 - row * 0.55
        is_prime = n in primes
        col_n = GOLD if is_prime else CHALK_DIM
        alpha = 0.9 if is_prime else 0.35
        ax1.text(x, y, str(n), fontsize=7, fontfamily="monospace",
                color=col_n, ha="center", va="center", alpha=alpha)

# Highlight pattern
ax1.text(0, -2.0, "GAUSS", fontsize=9, fontfamily="serif",
         fontweight="bold", color=GOLD, ha="center")
ax1.text(0, -2.3, "computational\npatience", fontsize=6,
         fontfamily="serif", fontstyle="italic", color=CHALK_DIM,
         ha="center", linespacing=1.1)

# ===================================================================
# Panel 2: Riemann — curved surface (saddle/hyperbolic)
# ===================================================================
ax2 = axes[1]

# Hyperbolic-like curves suggesting a saddle surface
thetas = np.linspace(0, 2 * np.pi, 100)
for r in np.linspace(0.3, 2.0, 8):
    x = r * np.cos(thetas) * (1 + 0.15 * np.sin(2 * thetas))
    y = r * np.sin(thetas) * (1 - 0.15 * np.sin(2 * thetas))
    x += rng.normal(0, 0.01, len(x))
    y += rng.normal(0, 0.01, len(y))
    ax2.plot(x, y, color=GOLD, lw=0.5, alpha=0.3 + 0.05 * r)

# Geodesics
for angle in np.linspace(0, np.pi, 6):
    t = np.linspace(-2, 2, 80)
    gx = t * np.cos(angle) + 0.1 * np.sin(t * 2) * np.sin(angle)
    gy = t * np.sin(angle) - 0.1 * np.sin(t * 2) * np.cos(angle)
    mask = gx**2 + gy**2 < 5
    ax2.plot(gx[mask], gy[mask], color=CHALK, lw=0.4, alpha=0.4)

ax2.text(0, -2.0, "RIEMANN", fontsize=9, fontfamily="serif",
         fontweight="bold", color=GOLD, ha="center")
ax2.text(0, -2.3, "conceptual\narchitecture", fontsize=6,
         fontfamily="serif", fontstyle="italic", color=CHALK_DIM,
         ha="center", linespacing=1.1)

# ===================================================================
# Panel 3: Erdős — network graph
# ===================================================================
ax3 = axes[2]

# Random network
n_nodes = 25
positions = rng.uniform(-1.8, 1.8, (n_nodes, 2))
# edges: connect nearby nodes
edges = []
for i in range(n_nodes):
    for j in range(i + 1, n_nodes):
        dist = np.sqrt((positions[i, 0] - positions[j, 0])**2 +
                       (positions[i, 1] - positions[j, 1])**2)
        if dist < 1.2 and rng.random() < 0.4:
            edges.append((i, j))

for i, j in edges:
    x1, y1 = positions[i]
    x2, y2 = positions[j]
    n_pts = 20
    t = np.linspace(0, 1, n_pts)
    lx = x1 + (x2 - x1) * t + rng.normal(0, 0.01, n_pts)
    ly = y1 + (y2 - y1) * t + rng.normal(0, 0.01, n_pts)
    ax3.plot(lx, ly, color=GOLD, lw=0.4, alpha=0.3)

# Central node (Erdős)
centre = np.array([0.0, 0.0])
for i in range(n_nodes):
    if np.sqrt(positions[i, 0]**2 + positions[i, 1]**2) < 1.5:
        ax3.plot([0, positions[i, 0]], [0, positions[i, 1]],
                color=CHALK, lw=0.5, alpha=0.3)

for i in range(n_nodes):
    col_n = CHALK if rng.random() > 0.5 else GOLD
    ax3.add_patch(Circle(positions[i], 0.08, facecolor=col_n,
                         edgecolor=CHALK, lw=0.3, alpha=0.6, zorder=5))

# Central node highlighted
ax3.add_patch(Circle((0, 0), 0.15, facecolor=GOLD,
                     edgecolor=CHALK, lw=0.8, alpha=0.9, zorder=6))

ax3.text(0, -2.0, "ERDŐS", fontsize=9, fontfamily="serif",
         fontweight="bold", color=GOLD, ha="center")
ax3.text(0, -2.3, "itinerant\nconnection", fontsize=6,
         fontfamily="serif", fontstyle="italic", color=CHALK_DIM,
         ha="center", linespacing=1.1)

# ===================================================================
# Panel 4: Tao — strategy tree / decision branches
# ===================================================================
ax4 = axes[3]

# Binary tree representing strategic choices
def draw_tree(ax, x, y, dx, dy, depth, max_depth):
    if depth >= max_depth:
        return
    # left branch
    x_l = x - dx
    y_l = y + dy
    n_pts = 15
    t = np.linspace(0, 1, n_pts)
    lx = x + (x_l - x) * t + rng.normal(0, 0.008, n_pts)
    ly = y + (y_l - y) * t + rng.normal(0, 0.008, n_pts)
    alpha = 0.7 - depth * 0.12
    ax.plot(lx, ly, color=GOLD, lw=max(0.4, 1.2 - depth * 0.2), alpha=alpha)
    # right branch
    x_r = x + dx
    y_r = y + dy
    lx = x + (x_r - x) * t + rng.normal(0, 0.008, n_pts)
    ly = y + (y_r - y) * t + rng.normal(0, 0.008, n_pts)
    ax.plot(lx, ly, color=GOLD, lw=max(0.4, 1.2 - depth * 0.2), alpha=alpha)

    # nodes
    for nx, ny in [(x_l, y_l), (x_r, y_r)]:
        s = max(0.03, 0.08 - depth * 0.012)
        ax.add_patch(Circle((nx, ny), s, facecolor=GOLD,
                           edgecolor=CHALK, lw=0.3, alpha=alpha, zorder=5))

    draw_tree(ax, x_l, y_l, dx * 0.55, dy * 0.7, depth + 1, max_depth)
    draw_tree(ax, x_r, y_r, dx * 0.55, dy * 0.7, depth + 1, max_depth)

# Root
ax4.add_patch(Circle((0, -1.5), 0.12, facecolor=CHALK,
                     edgecolor=GOLD, lw=0.8, alpha=0.9, zorder=6))
draw_tree(ax4, 0, -1.5, 1.2, 0.7, 0, 4)

# Labels on early branches
ax4.text(-0.85, -0.5, "try X?", fontsize=5, fontfamily="serif",
         fontstyle="italic", color=CHALK_DIM, ha="center", alpha=0.5)
ax4.text(0.85, -0.5, "try Y?", fontsize=5, fontfamily="serif",
         fontstyle="italic", color=CHALK_DIM, ha="center", alpha=0.5)

ax4.text(0, -2.0, "TAO", fontsize=9, fontfamily="serif",
         fontweight="bold", color=GOLD, ha="center")
ax4.text(0, -2.3, "strategic\nmetacognition", fontsize=6,
         fontfamily="serif", fontstyle="italic", color=CHALK_DIM,
         ha="center", linespacing=1.1)

# ===================================================================
# Panel 5: Thurston — hyperbolic tiling (Poincaré disk)
# ===================================================================
ax5 = axes[4]

# Poincaré disk boundary
theta = np.linspace(0, 2 * np.pi, 200)
ax5.plot(2.0 * np.cos(theta), 2.0 * np.sin(theta),
         color=CHALK, lw=0.8, alpha=0.4)

# Hyperbolic geodesics (arcs within the disk)
n_geo = 20
for _ in range(n_geo):
    a1 = rng.uniform(0, 2 * np.pi)
    a2 = a1 + rng.uniform(0.5, 2.5)
    # points on boundary
    p1 = 2.0 * np.array([np.cos(a1), np.sin(a1)])
    p2 = 2.0 * np.array([np.cos(a2), np.sin(a2)])
    # geodesic approximation: circular arc through p1, p2
    # orthogonal to boundary
    mid = (p1 + p2) / 2
    perp = np.array([-(p2[1] - p1[1]), p2[0] - p1[0]])
    perp_len = np.sqrt(perp[0]**2 + perp[1]**2)
    if perp_len < 0.01:
        continue
    perp = perp / perp_len
    # parametric arc
    t = np.linspace(0, 1, 40)
    # simple quadratic Bezier arc
    ctrl = mid + perp * rng.uniform(-1.5, 1.5)
    gx = (1 - t)**2 * p1[0] + 2 * (1 - t) * t * ctrl[0] + t**2 * p2[0]
    gy = (1 - t)**2 * p1[1] + 2 * (1 - t) * t * ctrl[1] + t**2 * p2[1]
    # clip to disk
    r = np.sqrt(gx**2 + gy**2)
    mask = r < 1.95
    gx += rng.normal(0, 0.008, len(gx))
    gy += rng.normal(0, 0.008, len(gy))
    ax5.plot(gx[mask], gy[mask], color=GOLD, lw=0.4, alpha=0.35)

# Scattered vertices
n_v = 40
v_r = rng.uniform(0, 1.8, n_v)
v_a = rng.uniform(0, 2 * np.pi, n_v)
vx = v_r * np.cos(v_a)
vy = v_r * np.sin(v_a)
ax5.scatter(vx, vy, s=rng.uniform(2, 8, n_v), c=GOLD,
            alpha=0.4, edgecolors="none", zorder=5)

ax5.text(0, -2.0, "THURSTON", fontsize=9, fontfamily="serif",
         fontweight="bold", color=GOLD, ha="center")
ax5.text(0, -2.3, "embodied\ngeometry", fontsize=6,
         fontfamily="serif", fontstyle="italic", color=CHALK_DIM,
         ha="center", linespacing=1.1)

# --- Suptitle ---
fig.suptitle("THE MATHEMATICIANS", fontsize=16, fontfamily="serif",
             fontweight="bold", color=GOLD, y=0.98)

plt.tight_layout(rect=[0, 0, 1, 0.95])

# --- Save ---
out_dir = Path(__file__).parent
for ext in ("png",):
    out = out_dir / f"mode-mathematicians.{ext}"
    fig.savefig(out, bbox_inches="tight", dpi=200,
                facecolor=fig.get_facecolor(), pad_inches=0.2)
    print(f"Saved: {out}")
plt.close()
#+end_src

#+RESULTS:
[[file:mode-mathematicians.png]]

** Notes on Reproduction

To regenerate all illustrations:

#+begin_example
uv run --with matplotlib --with numpy python3 gen-faculty-assembled.py
uv run --with matplotlib --with numpy python3 gen-mode-landau.py
uv run --with matplotlib --with numpy python3 gen-mode-measurers.py
uv run --with matplotlib --with numpy python3 gen-mode-mathematicians.py
#+end_example

The scripts use =matplotlib.use("Agg")= for headless rendering.
Seed =42= ensures reproducible hand-drawn jitter.
